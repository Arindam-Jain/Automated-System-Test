/*
 * input handler on ApplicationService level
 *
 * - remove readonly fields
 * - remove immutable fields on update
 * - add UUIDs
 * - asserts
 */

const cds = require('../../cds')

const enrichDataWithKeysFromWhere = require('../utils/enrichWithKeysFromWhere')
const { DRAFT_COLUMNS_MAP } = require('../../common/constants/draft')
const { checkInputConstraints } = require('../../cds-services/util/assert')
const getTemplate = require('../utils/template')
const templateProcessor = require('../utils/templateProcessor')
const { getDataFromCQN, setDataFromCQN } = require('../utils/data')
const { isMandatory, isReadOnly } = require('../aspects/utils')

const _processCategory = (row, key, category, isRoot, event, rucksack) => {
  if (typeof category === 'object') {
    category = category.category
  }

  // remember mandatory
  if (category === 'mandatory') {
    rucksack.mandatory = true
    return
  }
  // remove readonly & immutable (can also be complex, so do first)
  if (category === 'readonly' || (category === 'immutable' && event === 'UPDATE')) {
    delete row[key]
    rucksack.val = undefined
    return
  }
  // generate UUIDs
  if (category === 'uuid' && !rucksack.val && (event !== 'UPDATE' || !isRoot)) {
    rucksack.val = row[key] = cds.utils.uuid()
  }
}

const processorFn = (errors, req) => {
  const { event } = req

  return (row, key, element, plain, isRoot) => {
    const categories = plain.categories
    // ugly pointer passing for sonar
    const rucksack = { mandatory: false, val: row && row[key] }

    for (const category of categories) {
      _processCategory(row, key, category, isRoot, event, rucksack)
    }

    // asserts, if needed
    if (event === 'NEW' || event === 'PATCH') return
    if (rucksack.val == null && !rucksack.mandatory) return
    if (event === 'UPDATE' && rucksack.val === undefined) return

    // REVISIT: Convert checkInputConstraints to template mechanism
    checkInputConstraints(element, rucksack.val, errors)
  }
}

// params: element, target, parent, templateElements
const _pick = element => {
  // collect actions to apply
  const categories = []

  if (element['@assert.range'] || element['@assert.enum'] || element['@assert.format']) {
    categories.push('assert')
  }
  if (element._isMandatory) {
    categories.push('mandatory')
  }
  if (element._isReadOnly) {
    // includes @cds.on.insert and @cds.on.update
    categories.push('readonly')
  }
  if (element['@Core.Immutable']) {
    categories.push('immutable')
  }
  if (element.key && !DRAFT_COLUMNS_MAP[element.name] && element.type === 'cds.UUID') {
    categories.push('uuid')
  }

  if (categories.length) return { categories }
}

const _callError = (req, errors) => {
  if (errors.length !== 0) {
    for (const error of errors) {
      req.error(error)
    }
  }
}

function _handler(req) {
  if (!req.target) return

  const template = getTemplate('app-input', this, req.target, { pick: _pick })
  if (template.elements.size === 0) return

  const errors = []

  // REVISIT: req.data should point into req.query
  const data = getDataFromCQN(req.query)

  enrichDataWithKeysFromWhere(data, req, this)

  const arrayData = Array.isArray(data) ? data : [data]
  for (const row of arrayData) {
    templateProcessor(processorFn(errors, req), row, template)
  }

  // REVISIT: req.data should point into req.query
  setDataFromCQN(req)

  _callError(req, errors)
}

const processorFnForActionsFunctions = (errors, opName) => (row, tKey, element) => {
  const val = row && row[tKey]
  // REVISIT: Convert checkInputConstraints to template mechanism
  checkInputConstraints(element, val, errors, opName)
}

const KINDS_TO_VALIDATE = {
  entity: 1,
  type: 1
}

const _processActionFunctionRow = (row, param, key, errors, event, service) => {
  const val = row[key]

  // find out if all mandatory parameters were provided
  checkInputConstraints(param, val, errors, key)

  // validate elements of structured type
  if (val != null && param._type && KINDS_TO_VALIDATE[param._type.kind]) {
    const template = getTemplate('app-input-operation', service, param._type, {
      pick: _pick
    })
    if (template.elements.size === 0) return
    const valArray = Array.isArray(val) ? val : [val]
    for (const row of valArray) {
      templateProcessor(processorFnForActionsFunctions(errors, key), row, template)
    }
  }
}

const _processActionFunction = (row, eventParams, errors, event, service) => {
  for (const key of Object.keys(eventParams)) {
    let param = eventParams[key]
    if (!param._type && param.items) param = param.items
    _processActionFunctionRow(row, param, key, errors, event, service)
  }
}

const _getEventParameters = (req, service) => {
  // in bound case
  if (req.target) {
    if (req.target.actions && req.target.actions[req.event]) {
      return req.target.actions[req.event].params
    } else {
      return req.target.functions[req.event].params
    }
  } else {
    // in unbound case
    return service.model.definitions[`${service.name}.${req.event}`].params
  }
}

function _actionFunctionHandler(req) {
  const eventParams = _getEventParameters(req, this)
  if (!eventParams) return

  // REVISIT: find better solution
  // attach aspects, if not yet done
  for (const param of Object.values(eventParams)) {
    if ('_isMandatory' in param) continue
    param._isMandatory = isMandatory(param)
    param._isReadOnly = isReadOnly(param)
  }

  const errors = []
  const data = req.data
  const arrayData = Array.isArray(data) ? data : [data]
  for (const row of arrayData) {
    _processActionFunction(row, eventParams, errors, req.event, this)
  }
  _callError(req, errors)
}

_handler._initial = true
_actionFunctionHandler._initial = true

module.exports = function () {
  this.before(['CREATE', 'UPDATE', 'NEW', 'PATCH'], '*', _handler)

  const operationNames = []
  for (const operation of this.operations) {
    operationNames.push(operation.name.substring(this.name.length + 1))
  }
  if (operationNames.length > 0) {
    this.before(operationNames, _actionFunctionHandler)
  }

  for (const entity of this.entities) {
    const boundOps = []
    if (entity.actions) {
      boundOps.push(...Object.keys(entity.actions))
    }
    if (entity.functions) {
      boundOps.push(...Object.keys(entity.functions))
    }
    if (boundOps.length > 0) {
      this.before(boundOps, entity.name, _actionFunctionHandler)
    }
  }
}
