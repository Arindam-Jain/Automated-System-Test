const cds = require('../cds')
const LOG = cds.log('db|sql|hana')

/*
 * dynatrace
 */

const { dynatraceClient, isDynatraceEnabled } = require('./dynatrace')

/*
 * common
 */

const _ensureError = err => (err instanceof Error ? err : Object.assign(new Error(err.message), err))

function _disconnect(client) {
  return new Promise(resolve => {
    client.disconnect(err => {
      // REVISIT: what to do? ignore? crash app?
      if (err) {
        LOG._warn && LOG.warn(`error on client disconnect: `, err)
        resolve()
      } else resolve()
    })
  })
}

/*
 * hdb
 */

const HDB_MAX_RECONNECTS = process.env.HDB_MAX_RECONNECTS ? Number(process.env.HDB_MAX_RECONNECTS) : 0

const _addCheckServerIdentity = creds => {
  // REVISIT: copied from old cds-hana
  if (creds.sslValidateCertificate === false && creds.sslHostNameInCertificate) {
    const allowedHost = creds.sslHostNameInCertificate
    creds.checkServerIdentity = host => {
      if (host !== allowedHost) {
        throw new Error(
          `The name on the security certificate "${allowedHost}" is invalid or does not match the name of the site "${host}".`
        )
      }
    }
  }
}

const _registerReconnect = (client, tenant) => {
  client.on('close', hadErr => {
    if (hadErr) {
      client._reconnectAttempts = client._reconnectAttempts || 0
      client._reconnectAttempts++

      if (client._reconnectAttempts <= HDB_MAX_RECONNECTS) {
        // try to re-connect
        client.connect(err => {
          if (err) {
            // should be true already, but just in case
            client.hadError = true
            LOG._error && LOG.error(`Error on hdb re-connect for tenant "${tenant}":`, err)
          } else {
            client.hadError = false
          }
        })
      } else {
        // should be true already, but just in case
        client.hadError = true
      }
    }
  })
}

function _connectHdb(creds, tenant) {
  _addCheckServerIdentity(creds)

  return new Promise((resolve, reject) => /* NOSONAR */ {
    const hdbClient = this.createClient(creds)
    hdbClient.name = this.name // TODO find better way?

    const client = isDynatraceEnabled() ? dynatraceClient(hdbClient, creds, tenant) : hdbClient

    client.once('error', err => {
      client.hadError = true
      LOG._warn && LOG.warn('hdb client error:', err)
    })

    const start = LOG._debug && Date.now()
    client.connect(err => {
      if (err) {
        LOG._error && LOG.error(`Error on hdb connect for tenant "${tenant}":`, err)
        reject(_ensureError(err))
      } else {
        // only register reconnect if env variable (PRIVATE!!!) is set
        if (HDB_MAX_RECONNECTS) {
          _registerReconnect(client, tenant)
        }

        if (creds.schema) {
          client.exec(`SET SCHEMA ${creds.schema}`, err => {
            if (err) reject(Object.assign(new Error('Could not set schema'), err))
            else {
              LOG._debug && LOG.debug(`Elapsed time to create new db connection: ${Date.now() - start}ms`)
              resolve(client)
            }
          })
        } else {
          LOG._debug && LOG.debug(`Elapsed time to create new db connection: ${Date.now() - start}ms`)
          resolve(client)
        }
      }
    })
  })
}

/*
 * hana-client
 */

function _connectHanaClient(creds, tenant) {
  return new Promise((resolve, reject) => {
    const hanaClient = this.createConnection()

    hanaClient.name = this.name // TODO find better way?
    // ugly, but we need it for the hana-client streaming extension.
    // "client" does not contain the credentials in case of hana-client.
    hanaClient._creds = creds

    const client = isDynatraceEnabled() ? dynatraceClient(hanaClient, creds, tenant) : hanaClient

    if (creds.schema) {
      // REVISIT
      creds.CURRENTSCHEMA = creds.schema
    }

    const start = LOG._debug && Date.now()
    client.connect(creds, err => {
      if (err) {
        LOG._error && LOG.error(`error on hana-client connect for tenant "${tenant}"`, err)
        reject(_ensureError(err))
      } else {
        LOG._debug && LOG.debug(`Elapsed time to create new db connection: ${Date.now() - start}ms`)
        resolve(client)
      }
    })
  })
}

/*
 * facade
 */

let driver

const _getHanaDriver = (name = 'hdb') => {
  if (driver) return driver

  try {
    driver = Object.assign({ name }, require(name))

    driver.__connect = (...args) =>
      name === 'hdb' ? _connectHdb.call(driver, ...args) : _connectHanaClient.call(driver, ...args)
    driver.__disconnect = _disconnect
    driver.__isConnected = client => {
      if (name === 'hdb') {
        return !client.hadError && client.readyState === 'connected'
      }

      return client.state() === 'connected'
    }

    return driver
  } catch (e) {
    if (name === 'hdb') {
      LOG._debug && LOG.debug(`Failed to require "hdb" with error "${e.message}". Trying "@sap/hana-client" next.`)
      return _getHanaDriver('@sap/hana-client')
    } else {
      throw new Error(
        'Neither "hdb" nor "@sap/hana-client" could be required. Please make sure one of them is installed.'
      )
    }
  }
}

module.exports = _getHanaDriver('hdb')
