/* eslint-disable no-empty */
const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandlerOData = require('../buildTaskHandlerOData')
const BuildTaskFactory = require('../buildTaskFactory')
const { BuildMessage, BuildError } = require('../util')
const { BUILD_TASK_HANA, FOLDER_GEN, SEVERITY_WARNING } = require('../constants')
const DEBUG = process.env.DEBUG

const FOLDER_SDC = "sdc"
const FOLDER_NODE_MODULES = "node_modules"
const FOLDER_TEMPLATES = "tpl"

class MtxModuleBuilder extends BuildTaskHandlerOData {
    constructor(task, buildOptions) {
        super("Multitenant Application Builder", task, buildOptions)
    }

    init() {
        if (this.buildOptions.root === this.buildOptions.target) {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN, FOLDER_SDC)
        } else {
            this.task.dest = path.join(this.task.dest, FOLDER_SDC)
        }
    }

    async build() {
        const modelPaths = this.resolveModel()
        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skipping build")
            return
        }
        if (DEBUG) {
            this.logger.log(`[cds] - model: ${this.stripProjectPaths(modelPaths).join(", ")}`)
        }

        const model = await this.loadModel(modelPaths)

        // custom build tasks for srv and db modules might be defined
        const tenantDbPath = await this._getHanaTenantDbPath(modelPaths)

        // validate extension whitlists defined for this SaaS application
        this._validateExtensionWhitelists(model, tenantDbPath)

        // copy base model sources
        await Promise.all(model._sources.map(src => {
            if (src.includes(FOLDER_NODE_MODULES)) {
                return this.copy(src).to(path.join(this.task.dest, src.substr(src.indexOf(FOLDER_NODE_MODULES))))
            } else {
                const relSrc = path.relative(this.buildOptions.root, src)
                if (relSrc.startsWith("..")) {
                    this.logger.warn(`[cds] - model file is out of project scope, skipping file ${src}`)
                    return Promise.resolve()
                }
                return this.copy(src).to(path.join(this.task.dest, relSrc))
            }
        }))

        // collect and write language bundles into single i18n.json file
        await this.copyLanguageBundles(model, this.task.dest)

        // copy native hana content and templates
        await this._copyNativeContent(this.task.src, this.task.dest, tenantDbPath)
    }

    async clean() {
        // staging build content is deleted by BuildTaskEngine
        if (this.buildOptions.root === this.buildOptions.target) {
            // delete entire folder 'gen'
            const genDest = path.dirname(this.task.dest)
            if (path.basename(genDest) === FOLDER_GEN) {
                if (DEBUG) {
                    this.logger.log(`Deleting build target folder ${genDest}`)
                }
                await fs.remove(genDest)
            }
        }
    }

    async _copyNativeContent(src, dest, tenantDbPath) {
        // copying tmplates
        const tplSrc = path.join(src, FOLDER_TEMPLATES)
        if (fs.existsSync(tplSrc)) {
            const tplDest = path.join(path.dirname(dest), FOLDER_TEMPLATES)
            await this._copyTemplates(tplSrc, tplDest)
        }

        if (tenantDbPath) {
            // copy any static HANA artefacts, e.g. .csv files
            const dbDest = path.resolve(dest, path.relative(this.buildOptions.root, tenantDbPath))
            await this._copyNativeHanaContent(tenantDbPath, dbDest)
        }
    }

    async _copyNativeHanaContent(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_NODE_MODULES
            }
            return /\.csv$|\.cds$|\.hdb.*$|^\.hdi.*|^undeploy\.json/.test(path.basename(entry))
        })
    }

    async _copyTemplates(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isFile()) {
                return /\.cds$/.test(path.basename(entry))
            }
            return true
        })
    }

    /**
     * Extensions shall be restricted to relevant entities, by default all entities and services can be extended.
     * Empty whitelists indicate that all services or entities can be extended.
     * <br>
     * A warning is logged in case neither a 'entity-whitelist' nor a o service-whitelist has been defined.
     * An error is thrown in case a invalid entry is found.
     *
     * @param {Object} csn - the compiled csn for this SaaS application
     */
    _validateExtensionWhitelists(csn, tenantDbPath) {
        let entityWhitelist = this.env.get("mtx.entity-whitelist")
        let serviceWhitelist = this.env.get("mtx.service-whitelist")

        // for java projects mtx configuration is part of sidecar config
        if (!entityWhitelist && !serviceWhitelist && tenantDbPath) {
            const dbEnv = this.env.for("cds", tenantDbPath)
            if (dbEnv && dbEnv.get("mtx")) {
                entityWhitelist = dbEnv.get("mtx.entity-whitelist")
                serviceWhitelist = dbEnv.get("mtx.service-whitelist")
            }
        }

        if (!Array.isArray(entityWhitelist) || !Array.isArray(serviceWhitelist)) {
            this.pushMessages(new BuildMessage("No 'entity-whitelist' or 'service-whitelist' defined. By default all entities and services can be extended.", SEVERITY_WARNING)) //NOSONAR
        }

        if (Array.isArray(entityWhitelist) || Array.isArray(serviceWhitelist)) {
            // validate whitelist entries
            const reflectedCsn = this.cds.reflect(csn)
            const errornousEntries = new Set()
            if (Array.isArray(entityWhitelist)) {
                entityWhitelist.forEach(entityName => {
                    if (!reflectedCsn.find(entity => entity.name === entityName && entity.kind === 'entity')) {
                        errornousEntries.add(entityName)
                    }
                })
            }
            if (Array.isArray(serviceWhitelist)) {
                serviceWhitelist.forEach(serviceName => {
                    if (!reflectedCsn.find(service => service.name === serviceName && service.kind === 'service')) {
                        errornousEntries.add(serviceName)
                    }
                })
            }
            if (errornousEntries.size > 0) {
                throw new BuildError(`Invalid entries found in 'entity-whitelist' or 'service-whitelist' - [${[...errornousEntries].join(", ")}]`) //NOSONAR
            }
        }
    }

    /**
     * Returns the build tasks of this project - either user defined or calculated by BuildTaskFactory.
     * A build task of type 'hana' is enforced in order to copy existing native hana artefacts later on.
     * 
     * @param {Array<string>} modelPaths - the .cds root model files defined by this build task's model options
     * @returns {string} the src folder of the tenant db module
     */
    async _getHanaTenantDbPath(modelPaths) {
        let tasks = this.buildOptions.tasks || []

        // ensure that the hana task is contained even if this mtx task has been executed solely using "cds build --for mtx"
        if (!tasks.find(task => task.for === BUILD_TASK_HANA)) {
            //mtx task might have been executed as separate task
            const buildTaskFactory = new BuildTaskFactory(this.logger, this.cds)
            tasks = buildTaskFactory._getExistingTasks(this.buildOptions)
            if (tasks.length === 0) {
                tasks = await buildTaskFactory._createTasksFromConfig(this.buildOptions)
            }
        }
        // the SaaS app might use a tenant aware db as well as a shared db deployed using static hdi-deployer
        // pick the hana build task refering to the tenant aware db - the src path has to be contained in this build task's model options
        const hanaDbPaths = tasks.filter(task => task.for === BUILD_TASK_HANA).map(hanaTask => path.resolve(this.buildOptions.root, hanaTask.src || this.env.folders.db))
        let tenantDbPath = hanaDbPaths.find(hanaDbPath => hanaDbPaths.length === 1 || modelPaths.some(modelPath => path.dirname(modelPath) === hanaDbPath))

        if (!tenantDbPath) {
            tenantDbPath = path.join(this.buildOptions.root, this.env.folders.db)
            if (hanaDbPaths.length === 0) {
                this.pushMessages(new BuildMessage(`[cds] - no 'hana' build task found, use default location '${tenantDbPath}'`, SEVERITY_WARNING))
            } else {
                this.pushMessages(new BuildMessage(`[cds] - no 'hana' build task found matching model scope '${this.task.options.model}', use default location '${tenantDbPath}'`, SEVERITY_WARNING))
            }
        }
        return tenantDbPath
    }
}
module.exports = MtxModuleBuilder
